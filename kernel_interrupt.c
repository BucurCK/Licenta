//#include <stdint.h>
//#include <stdbool.h>
//#include <xmc_common.h>   // includes stdint stdbool stdef stdstring
//#include "driver_pwm.h"
//#include "main.h"
//#include "motor_data_update.h"
//#include "driver_adc.h"
//#include "io.h"
//#include "transform.h"
//#include <probe_scope.h>
//#include "Encoder.h"
//
///*Interrupt variables*/
//uint16_t main_interrupt_counter=0;
//uint16_t wait_100_us = 2; 			//50us * wait | 2 = 100us | 1000 = 50ms
//
//
///*Functions */
//
//void CCU80_3_IRQHandler (void)
//{
//	main_interrupt_counter++;
///*
// * Fast compute "loop"
// * Every 100us compute speed,mechanical/electrical position, field, dq_abc transformation
// */
//	if (main_interrupt_counter == wait_100_us)
//	{
//		main_interrupt_counter = 0;
//		compute_fast_speed();
//		compute_fast_mechanical_position();
//		compute_fast_electrical_position();
//		compute_fast_field();
//		dq_abc();
//		pwm_update(u_a_ref, u_b_ref, u_c_ref);
//		ProbeScope_Sampling();
//	}
//}
//
//
//void interrupt_init(void)
//{
///*  Reset CCU80 */
//	SCU_RESET->PRSET0 |= SCU_RESET_PRSET0_CCU80RS_Msk ;
//
///* Clear reset of CCU80 */
//	SCU_RESET->PRCLR0 |= SCU_RESET_PRCLR0_CCU80RS_Msk ;
//
///* Enable CCU8 via clkset */
//	SCU_CLK->CLKSET |= SCU_CLK_CLKSET_CCUCEN_Msk ;
//
///* Enable prescaler */
//	CCU80->GIDLC |= CCU8_GIDLC_SPRB_Msk;
//
///*  GCTRL configuration from reset (0x 0000 0000)*/
//
//	/*enable interrupt */
//	CCU80_CC83->INTE |= CCU8_CC8_INTE_CMD1E_Msk;
//
///*    Set timer to center aligned mode */
//	CCU80_CC83->TC |= (uint32_t)(CCU8_CC8_TC_TCM_Msk);
//
//	/*   SHADOW:Define the period value of Compare Channel 1 */
//	CCU80_CC83->PRS|= (uint32_t)(CCU8_CC8_PRS_PR_Value << CCU8_CC8_PR_PR_Pos);
//
///*   SHADOW:Define the compare value of Compare Channel 1 */
//	CCU80_CC83->CR1S |= (uint32_t)(CCU80_CC83_CR_Value << CCU8_CC8_CR1_CR1_Pos);
//
///*   Request shadow transfer  */
//	CCU80->GCSS |= (CCU8_GCSS_S0SE_Msk | CCU8_GCSS_S1SE_Msk | CCU8_GCSS_S2SE_Msk | CCU8_GCSS_S3SE_Msk);
//
///*  Enable CC80*/
//	CCU80->GIDLC |= (CCU8_GIDLC_CS0I_Msk | CCU8_GIDLC_CS1I_Msk | CCU8_GIDLC_CS2I_Msk | CCU8_GIDLC_CS3I_Msk) ;
//
///*   Clear the timer run bit(TRBC) and timer (TCC) */
//	CCU80_CC83->TCCLR |= (uint32_t)(CCU8_CC8_TCCLR_TRBC_Msk);
//	CCU80_CC83->TCCLR |= (uint32_t)(CCU8_CC8_TCCLR_TCC_Msk);
//
//	CCU80_CC83->INS |= CCU8_IN_H << CCU8_CC8_INS_EV0IS_Pos;
//	CCU80_CC83->INS |= ACTIVE_ON_RISING_EDGE << CCU8_CC8_INS_EV0EM_Pos;
//	CCU80_CC83->CMC |= 1 << CCU8_CC8_CMC_STRTS_Pos;
//
//	//2638 - configure the timer CCU8 to generate  a service request when matching compare channel 1 while counting down
//	CCU80_CC83->INS  |=  15 << CCU8_CC8_INS_EV2IS_Pos;   //which input is used -> input CC80.IN3P
//	CCU80_CC83->INS  &=  ~CCU8_CC8_INS_EV2EM_Msk;	 // event active on rising edge
//	CCU80_CC83->INS  |=  1  << CCU8_CC8_INS_EV2EM_Pos;	 // event active on rising edge
//
//	//2672 - Enables the Channel 1 compare match while counting down interrupt
//	CCU80_CC83->INTE |= 1 << CCU8_CC8_INTE_CMD1E_Pos;
//
//	//2675 - The interrupt generated by compare match of channel 1 is forwarded to CC8ySR3
//	CCU80_CC83->SRS  |= 3 << CCU8_CC8_SRS_CM1SR_Pos;
//	NVIC_ClearPendingIRQ(VADC0_G0_2_IRQn);
//	NVIC_EnableIRQ(CCU80_3_IRQn); //enable irq
//	NVIC_ClearPendingIRQ(CCU80_3_IRQn);
//	NVIC_EnableIRQ(CCU80_3_IRQn); //enable irq
//
//	//This function configures ccu80 timer  to priority level 30
//	NVIC_SetPriority(CCU80_3_IRQn, 1U);
//	NVIC_SetPriority(VADC0_G0_2_IRQn, 30U);
//	//Channel 1 compare match service request selector
//
//	SCU_GENERAL->CCUCON |= SCU_GENERAL_CCUCON_GSC80_Msk;
//	SCU_GENERAL->CCUCON &= ~SCU_GENERAL_CCUCON_GSC80_Msk;
//
//}
