   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "transform.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm CCU8_CC8_CR1_CR1_Value,4,4
  20              	 .global mechanical_position_fast
  21              	 .section .bss.mechanical_position_fast,"aw",%nobits
  22              	 .align 2
  25              	mechanical_position_fast:
  26 0000 00000000 	 .space 4
  27              	 .global electrical_position_modulo_fast
  28              	 .section .bss.electrical_position_modulo_fast,"aw",%nobits
  29              	 .align 2
  32              	electrical_position_modulo_fast:
  33 0000 00000000 	 .space 4
  34              	 .global theta_fast
  35              	 .section .bss.theta_fast,"aw",%nobits
  36              	 .align 2
  39              	theta_fast:
  40 0000 00000000 	 .space 4
  41              	 .global sin_theta_fast
  42              	 .section .bss.sin_theta_fast,"aw",%nobits
  43              	 .align 2
  46              	sin_theta_fast:
  47 0000 00000000 	 .space 4
  48              	 .global cos_theta_fast
  49              	 .section .bss.cos_theta_fast,"aw",%nobits
  50              	 .align 2
  53              	cos_theta_fast:
  54 0000 00000000 	 .space 4
  55              	 .global timer_value_fast
  56              	 .section .bss.timer_value_fast,"aw",%nobits
  57              	 .align 1
  60              	timer_value_fast:
  61 0000 0000     	 .space 2
  62              	 .global timer_value_old_fast
  63              	 .section .bss.timer_value_old_fast,"aw",%nobits
  64              	 .align 1
  67              	timer_value_old_fast:
  68 0000 0000     	 .space 2
  69              	 .global speed_value_fast
  70              	 .section .bss.speed_value_fast,"aw",%nobits
  71              	 .align 1
  74              	speed_value_fast:
  75 0000 0000     	 .space 2
  76              	 .global encoder_resolution
  77              	 .section .bss.encoder_resolution,"aw",%nobits
  78              	 .align 1
  81              	encoder_resolution:
  82 0000 0000     	 .space 2
  83              	 .global pp
  84              	 .section .bss.pp,"aw",%nobits
  87              	pp:
  88 0000 00       	 .space 1
  89              	 .global electrical_resolution
  90              	 .section .bss.electrical_resolution,"aw",%nobits
  91              	 .align 1
  94              	electrical_resolution:
  95 0000 0000     	 .space 2
  96              	 .comm u_a_ref,4,4
  97              	 .comm u_b_ref,4,4
  98              	 .comm u_c_ref,4,4
  99              	 .comm i_d,4,4
 100              	 .comm i_q,4,4
 101              	 .comm i_alpha,4,4
 102              	 .comm i_beta,4,4
 103              	 .comm u_alpha,4,4
 104              	 .comm u_beta,4,4
 105              	 .section .text.motor_data_init,"ax",%progbits
 106              	 .align 2
 107              	 .global motor_data_init
 108              	 .thumb
 109              	 .thumb_func
 111              	motor_data_init:
 112              	.LFB196:
 113              	 .file 1 "../transform.c"
   1:../transform.c **** #include <stdint.h>
   2:../transform.c **** #include <stdbool.h>
   3:../transform.c **** #include <xmc_common.h>
   4:../transform.c **** #include "driver_pwm.h"
   5:../transform.c **** #include "motor_data_update.h"
   6:../transform.c **** #include "transform.h"
   7:../transform.c **** #include "main.h"
   8:../transform.c **** #include <math.h>
   9:../transform.c **** #include "Encoder.h"
  10:../transform.c **** #include "driver_adc.h"
  11:../transform.c **** #include "pi_regulator.h"
  12:../transform.c **** #include "state_machine.h"
  13:../transform.c **** #include <math.h>
  14:../transform.c **** 
  15:../transform.c **** int32_t mechanical_position_fast = 0;		 // compute the mechanical position of the motor based on sp
  16:../transform.c **** int32_t electrical_position_modulo_fast = 0; // the module of electrical position based on electric
  17:../transform.c **** float_t theta_fast = 0;						 // electric angle
  18:../transform.c **** float_t sin_theta_fast = 0;					 // sin(theta)
  19:../transform.c **** float_t cos_theta_fast = 0;					 // cos(theta)
  20:../transform.c **** uint16_t timer_value_fast = 0;				 // Stored value of CCU40 timer for encoder
  21:../transform.c **** uint16_t timer_value_old_fast = 0;			 //*Last* read of timer value for speed computation
  22:../transform.c **** int16_t speed_value_fast = 0;				 // Speed value based on 2 timer values
  23:../transform.c **** int16_t encoder_resolution = 0;			 // Resolution of encoder | 4*resolution
  24:../transform.c **** int8_t pp = 0;								 // Number of electric poles : Total_steps/mechanical_steps_electric_angle
  25:../transform.c **** int16_t electrical_resolution = 0;			 // Electrical resolution based on encoder resolution and numb
  26:../transform.c **** float_t u_a_ref, u_b_ref, u_c_ref;			 // abc voltage | -32768 -- 32,767
  27:../transform.c **** float_t i_d, i_q;							 // dq voltage																   *
  28:../transform.c **** float_t i_alpha, i_beta;					 // currents for dq computation
  29:../transform.c **** float_t u_alpha, u_beta;					 // voltage for abc computation
  30:../transform.c **** /*
  31:../transform.c **** 	Initialize motor data
  32:../transform.c **** 	enc_res = encoder resolution
  33:../transform.c **** 	motor_steps = number of steps
  34:../transform.c **** */
  35:../transform.c **** void motor_data_init(int16_t enc_res, int8_t motor_steps)
  36:../transform.c **** {
 114              	 .loc 1 36 0
 115              	 .cfi_startproc
 116              	 
 117              	 
 118              	 
 119 0000 80B4     	 push {r7}
 120              	.LCFI0:
 121              	 .cfi_def_cfa_offset 4
 122              	 .cfi_offset 7,-4
 123 0002 83B0     	 sub sp,sp,#12
 124              	.LCFI1:
 125              	 .cfi_def_cfa_offset 16
 126 0004 00AF     	 add r7,sp,#0
 127              	.LCFI2:
 128              	 .cfi_def_cfa_register 7
 129 0006 0346     	 mov r3,r0
 130 0008 0A46     	 mov r2,r1
 131 000a FB80     	 strh r3,[r7,#6]
 132 000c 1346     	 mov r3,r2
 133 000e 7B71     	 strb r3,[r7,#5]
  37:../transform.c **** 	encoder_resolution = enc_res * 4;					//4000
 134              	 .loc 1 37 0
 135 0010 FB88     	 ldrh r3,[r7,#6]
 136 0012 9B00     	 lsls r3,r3,#2
 137 0014 9BB2     	 uxth r3,r3
 138 0016 9AB2     	 uxth r2,r3
 139 0018 0D4B     	 ldr r3,.L3
 140 001a 1A80     	 strh r2,[r3]
  38:../transform.c **** 	pp = motor_steps / 4;								//25
 141              	 .loc 1 38 0
 142 001c 97F90530 	 ldrsb r3,[r7,#5]
 143 0020 002B     	 cmp r3,#0
 144 0022 00DA     	 bge .L2
 145 0024 0333     	 adds r3,r3,#3
 146              	.L2:
 147 0026 9B10     	 asrs r3,r3,#2
 148 0028 DAB2     	 uxtb r2,r3
 149 002a 0A4B     	 ldr r3,.L3+4
 150 002c 1A70     	 strb r2,[r3]
  39:../transform.c **** 	electrical_resolution = encoder_resolution / pp;	//160
 151              	 .loc 1 39 0
 152 002e 084B     	 ldr r3,.L3
 153 0030 1B88     	 ldrh r3,[r3]
 154 0032 1AB2     	 sxth r2,r3
 155 0034 074B     	 ldr r3,.L3+4
 156 0036 1B78     	 ldrb r3,[r3]
 157 0038 5BB2     	 sxtb r3,r3
 158 003a 92FBF3F3 	 sdiv r3,r2,r3
 159 003e 9AB2     	 uxth r2,r3
 160 0040 054B     	 ldr r3,.L3+8
 161 0042 1A80     	 strh r2,[r3]
  40:../transform.c **** }
 162              	 .loc 1 40 0
 163 0044 0C37     	 adds r7,r7,#12
 164              	.LCFI3:
 165              	 .cfi_def_cfa_offset 4
 166 0046 BD46     	 mov sp,r7
 167              	.LCFI4:
 168              	 .cfi_def_cfa_register 13
 169              	 
 170 0048 5DF8047B 	 ldr r7,[sp],#4
 171              	.LCFI5:
 172              	 .cfi_restore 7
 173              	 .cfi_def_cfa_offset 0
 174 004c 7047     	 bx lr
 175              	.L4:
 176 004e 00BF     	 .align 2
 177              	.L3:
 178 0050 00000000 	 .word encoder_resolution
 179 0054 00000000 	 .word pp
 180 0058 00000000 	 .word electrical_resolution
 181              	 .cfi_endproc
 182              	.LFE196:
 184              	 .section .text.abc_dq,"ax",%progbits
 185              	 .align 2
 186              	 .global abc_dq
 187              	 .thumb
 188              	 .thumb_func
 190              	abc_dq:
 191              	.LFB197:
  41:../transform.c **** 
  42:../transform.c **** /*
  43:../transform.c ****  * Convert three-phase electrical signals from time-domain to dq0-reference frame
  44:../transform.c ****  */
  45:../transform.c **** void abc_dq(void)
  46:../transform.c **** {
 192              	 .loc 1 46 0
 193              	 .cfi_startproc
 194              	 
 195              	 
 196              	 
 197 0000 80B4     	 push {r7}
 198              	.LCFI6:
 199              	 .cfi_def_cfa_offset 4
 200              	 .cfi_offset 7,-4
 201 0002 00AF     	 add r7,sp,#0
 202              	.LCFI7:
 203              	 .cfi_def_cfa_register 7
  47:../transform.c **** 	// Initializa alpha values
  48:../transform.c **** 	i_alpha = ia;
 204              	 .loc 1 48 0
 205 0004 204B     	 ldr r3,.L6
 206 0006 1B88     	 ldrh r3,[r3]
 207 0008 1BB2     	 sxth r3,r3
 208 000a 07EE903A 	 fmsr s15,r3
 209 000e F8EEE77A 	 fsitos s15,s15
 210 0012 1E4B     	 ldr r3,.L6+4
 211 0014 C3ED007A 	 fsts s15,[r3]
  49:../transform.c **** 	i_beta = ic;
 212              	 .loc 1 49 0
 213 0018 1D4B     	 ldr r3,.L6+8
 214 001a 1B88     	 ldrh r3,[r3]
 215 001c 1BB2     	 sxth r3,r3
 216 001e 07EE903A 	 fmsr s15,r3
 217 0022 F8EEE77A 	 fsitos s15,s15
 218 0026 1B4B     	 ldr r3,.L6+12
 219 0028 C3ED007A 	 fsts s15,[r3]
  50:../transform.c **** 
  51:../transform.c **** 	// Park Transformation
  52:../transform.c **** 	i_d = i_alpha * cos_theta_fast + i_beta * sin_theta_fast;
 220              	 .loc 1 52 0
 221 002c 174B     	 ldr r3,.L6+4
 222 002e 93ED007A 	 flds s14,[r3]
 223 0032 194B     	 ldr r3,.L6+16
 224 0034 D3ED007A 	 flds s15,[r3]
 225 0038 27EE277A 	 fmuls s14,s14,s15
 226 003c 154B     	 ldr r3,.L6+12
 227 003e D3ED006A 	 flds s13,[r3]
 228 0042 164B     	 ldr r3,.L6+20
 229 0044 D3ED007A 	 flds s15,[r3]
 230 0048 66EEA77A 	 fmuls s15,s13,s15
 231 004c 77EE277A 	 fadds s15,s14,s15
 232 0050 134B     	 ldr r3,.L6+24
 233 0052 C3ED007A 	 fsts s15,[r3]
  53:../transform.c **** 	i_q = i_beta * cos_theta_fast - i_alpha * sin_theta_fast;
 234              	 .loc 1 53 0
 235 0056 0F4B     	 ldr r3,.L6+12
 236 0058 93ED007A 	 flds s14,[r3]
 237 005c 0E4B     	 ldr r3,.L6+16
 238 005e D3ED007A 	 flds s15,[r3]
 239 0062 27EE277A 	 fmuls s14,s14,s15
 240 0066 094B     	 ldr r3,.L6+4
 241 0068 D3ED006A 	 flds s13,[r3]
 242 006c 0B4B     	 ldr r3,.L6+20
 243 006e D3ED007A 	 flds s15,[r3]
 244 0072 66EEA77A 	 fmuls s15,s13,s15
 245 0076 77EE677A 	 fsubs s15,s14,s15
 246 007a 0A4B     	 ldr r3,.L6+28
 247 007c C3ED007A 	 fsts s15,[r3]
  54:../transform.c **** }
 248              	 .loc 1 54 0
 249 0080 BD46     	 mov sp,r7
 250              	.LCFI8:
 251              	 .cfi_def_cfa_register 13
 252              	 
 253 0082 5DF8047B 	 ldr r7,[sp],#4
 254              	.LCFI9:
 255              	 .cfi_restore 7
 256              	 .cfi_def_cfa_offset 0
 257 0086 7047     	 bx lr
 258              	.L7:
 259              	 .align 2
 260              	.L6:
 261 0088 00000000 	 .word ia
 262 008c 00000000 	 .word i_alpha
 263 0090 00000000 	 .word ic
 264 0094 00000000 	 .word i_beta
 265 0098 00000000 	 .word cos_theta_fast
 266 009c 00000000 	 .word sin_theta_fast
 267 00a0 00000000 	 .word i_d
 268 00a4 00000000 	 .word i_q
 269              	 .cfi_endproc
 270              	.LFE197:
 272              	 .section .text.dq_abc,"ax",%progbits
 273              	 .align 2
 274              	 .global dq_abc
 275              	 .thumb
 276              	 .thumb_func
 278              	dq_abc:
 279              	.LFB198:
  55:../transform.c **** 
  56:../transform.c **** /*
  57:../transform.c ****  * Convert two-phase balanced sinusoidal signals to three-phase electrical signals
  58:../transform.c ****  */
  59:../transform.c **** void dq_abc(void)
  60:../transform.c **** {
 280              	 .loc 1 60 0
 281              	 .cfi_startproc
 282              	 
 283              	 
 284              	 
 285 0000 80B4     	 push {r7}
 286              	.LCFI10:
 287              	 .cfi_def_cfa_offset 4
 288              	 .cfi_offset 7,-4
 289 0002 00AF     	 add r7,sp,#0
 290              	.LCFI11:
 291              	 .cfi_def_cfa_register 7
  61:../transform.c **** 
  62:../transform.c **** 	// The Inverse Park Transformation
  63:../transform.c **** 	u_alpha = u_d_ref * cos_theta_fast - u_q_ref * sin_theta_fast;
 292              	 .loc 1 63 0
 293 0004 364B     	 ldr r3,.L23
 294 0006 93ED007A 	 flds s14,[r3]
 295 000a 364B     	 ldr r3,.L23+4
 296 000c D3ED007A 	 flds s15,[r3]
 297 0010 27EE277A 	 fmuls s14,s14,s15
 298 0014 344B     	 ldr r3,.L23+8
 299 0016 D3ED006A 	 flds s13,[r3]
 300 001a 344B     	 ldr r3,.L23+12
 301 001c D3ED007A 	 flds s15,[r3]
 302 0020 66EEA77A 	 fmuls s15,s13,s15
 303 0024 77EE677A 	 fsubs s15,s14,s15
 304 0028 314B     	 ldr r3,.L23+16
 305 002a C3ED007A 	 fsts s15,[r3]
  64:../transform.c **** 	u_beta = u_q_ref * cos_theta_fast + u_d_ref * sin_theta_fast;
 306              	 .loc 1 64 0
 307 002e 2E4B     	 ldr r3,.L23+8
 308 0030 93ED007A 	 flds s14,[r3]
 309 0034 2B4B     	 ldr r3,.L23+4
 310 0036 D3ED007A 	 flds s15,[r3]
 311 003a 27EE277A 	 fmuls s14,s14,s15
 312 003e 284B     	 ldr r3,.L23
 313 0040 D3ED006A 	 flds s13,[r3]
 314 0044 294B     	 ldr r3,.L23+12
 315 0046 D3ED007A 	 flds s15,[r3]
 316 004a 66EEA77A 	 fmuls s15,s13,s15
 317 004e 77EE277A 	 fadds s15,s14,s15
 318 0052 284B     	 ldr r3,.L23+20
 319 0054 C3ED007A 	 fsts s15,[r3]
  65:../transform.c **** 
  66:../transform.c **** 	// The Inverse Clarke Transformation
  67:../transform.c **** 	u_a_ref = u_alpha;
 320              	 .loc 1 67 0
 321 0058 254B     	 ldr r3,.L23+16
 322 005a 1B68     	 ldr r3,[r3]
 323 005c 264A     	 ldr r2,.L23+24
 324 005e 1360     	 str r3,[r2]
  68:../transform.c **** 	u_b_ref = u_beta;
 325              	 .loc 1 68 0
 326 0060 244B     	 ldr r3,.L23+20
 327 0062 1B68     	 ldr r3,[r3]
 328 0064 254A     	 ldr r2,.L23+28
 329 0066 1360     	 str r3,[r2]
  69:../transform.c **** 
  70:../transform.c **** 	/*
  71:../transform.c **** 	 * Keeps the values in range of int16_t
  72:../transform.c **** 	 * Later on the Float values will be casted into Int
  73:../transform.c **** 	 */
  74:../transform.c **** 	if (u_a_ref > MAX_INT_16)
 330              	 .loc 1 74 0
 331 0068 234B     	 ldr r3,.L23+24
 332 006a D3ED007A 	 flds s15,[r3]
 333 006e 9FED247A 	 flds s14,.L23+32
 334 0072 F4EEC77A 	 fcmpes s15,s14
 335 0076 F1EE10FA 	 fmstat
 336 007a 03DD     	 ble .L21
  75:../transform.c **** 	{
  76:../transform.c **** 		u_a_ref = MAX_INT_16;
 337              	 .loc 1 76 0
 338 007c 1E4B     	 ldr r3,.L23+24
 339 007e 214A     	 ldr r2,.L23+36
 340 0080 1A60     	 str r2,[r3]
 341 0082 0DE0     	 b .L11
 342              	.L21:
  77:../transform.c **** 	}
  78:../transform.c **** 	else if (u_a_ref < MIN_UINT_16)
 343              	 .loc 1 78 0
 344 0084 1C4B     	 ldr r3,.L23+24
 345 0086 D3ED007A 	 flds s15,[r3]
 346 008a 9FED1F7A 	 flds s14,.L23+40
 347 008e F4EEC77A 	 fcmpes s15,s14
 348 0092 F1EE10FA 	 fmstat
 349 0096 03D5     	 bpl .L11
  79:../transform.c **** 	{
  80:../transform.c **** 		u_a_ref = MIN_UINT_16;
 350              	 .loc 1 80 0
 351 0098 174B     	 ldr r3,.L23+24
 352 009a 4FF04742 	 mov r2,#-956301312
 353 009e 1A60     	 str r2,[r3]
 354              	.L11:
  81:../transform.c **** 	}
  82:../transform.c **** 
  83:../transform.c **** 	if (u_b_ref > MAX_INT_16)
 355              	 .loc 1 83 0
 356 00a0 164B     	 ldr r3,.L23+28
 357 00a2 D3ED007A 	 flds s15,[r3]
 358 00a6 9FED167A 	 flds s14,.L23+32
 359 00aa F4EEC77A 	 fcmpes s15,s14
 360 00ae F1EE10FA 	 fmstat
 361 00b2 03DD     	 ble .L22
  84:../transform.c **** 	{
  85:../transform.c **** 		u_b_ref = MAX_INT_16;
 362              	 .loc 1 85 0
 363 00b4 114B     	 ldr r3,.L23+28
 364 00b6 134A     	 ldr r2,.L23+36
 365 00b8 1A60     	 str r2,[r3]
 366 00ba 0DE0     	 b .L8
 367              	.L22:
  86:../transform.c **** 	}
  87:../transform.c **** 	else if (u_b_ref < MIN_UINT_16)
 368              	 .loc 1 87 0
 369 00bc 0F4B     	 ldr r3,.L23+28
 370 00be D3ED007A 	 flds s15,[r3]
 371 00c2 9FED117A 	 flds s14,.L23+40
 372 00c6 F4EEC77A 	 fcmpes s15,s14
 373 00ca F1EE10FA 	 fmstat
 374 00ce 03D5     	 bpl .L8
  88:../transform.c **** 	{
  89:../transform.c **** 		u_a_ref = MIN_UINT_16;
 375              	 .loc 1 89 0
 376 00d0 094B     	 ldr r3,.L23+24
 377 00d2 4FF04742 	 mov r2,#-956301312
 378 00d6 1A60     	 str r2,[r3]
 379              	.L8:
  90:../transform.c **** 	}
  91:../transform.c **** }
 380              	 .loc 1 91 0
 381 00d8 BD46     	 mov sp,r7
 382              	.LCFI12:
 383              	 .cfi_def_cfa_register 13
 384              	 
 385 00da 5DF8047B 	 ldr r7,[sp],#4
 386              	.LCFI13:
 387              	 .cfi_restore 7
 388              	 .cfi_def_cfa_offset 0
 389 00de 7047     	 bx lr
 390              	.L24:
 391              	 .align 2
 392              	.L23:
 393 00e0 00000000 	 .word u_d_ref
 394 00e4 00000000 	 .word cos_theta_fast
 395 00e8 00000000 	 .word u_q_ref
 396 00ec 00000000 	 .word sin_theta_fast
 397 00f0 00000000 	 .word u_alpha
 398 00f4 00000000 	 .word u_beta
 399 00f8 00000000 	 .word u_a_ref
 400 00fc 00000000 	 .word u_b_ref
 401 0100 00FEFF46 	 .word 1191181824
 402 0104 00FEFF46 	 .word 1191181824
 403 0108 000000C7 	 .word -956301312
 404              	 .cfi_endproc
 405              	.LFE198:
 407              	 .section .text.compute_fast_speed,"ax",%progbits
 408              	 .align 2
 409              	 .global compute_fast_speed
 410              	 .thumb
 411              	 .thumb_func
 413              	compute_fast_speed:
 414              	.LFB199:
  92:../transform.c **** 
  93:../transform.c **** /*
  94:../transform.c ****  * Compute the speed based on the encoder increments, read from CCU40 Timer
  95:../transform.c ****  */
  96:../transform.c **** void compute_fast_speed(void) // SPEED = 1 for testing
  97:../transform.c **** {
 415              	 .loc 1 97 0
 416              	 .cfi_startproc
 417              	 
 418              	 
 419              	 
 420 0000 80B4     	 push {r7}
 421              	.LCFI14:
 422              	 .cfi_def_cfa_offset 4
 423              	 .cfi_offset 7,-4
 424 0002 00AF     	 add r7,sp,#0
 425              	.LCFI15:
 426              	 .cfi_def_cfa_register 7
  98:../transform.c **** 	timer_value_fast = CCU40_CC40->TIMER;
 427              	 .loc 1 98 0
 428 0004 0A4B     	 ldr r3,.L26
 429 0006 1B6F     	 ldr r3,[r3,#112]
 430 0008 9AB2     	 uxth r2,r3
 431 000a 0A4B     	 ldr r3,.L26+4
 432 000c 1A80     	 strh r2,[r3]
  99:../transform.c **** 	speed_value_fast = timer_value_fast - timer_value_old_fast;
 433              	 .loc 1 99 0
 434 000e 094B     	 ldr r3,.L26+4
 435 0010 1A88     	 ldrh r2,[r3]
 436 0012 094B     	 ldr r3,.L26+8
 437 0014 1B88     	 ldrh r3,[r3]
 438 0016 D31A     	 subs r3,r2,r3
 439 0018 9BB2     	 uxth r3,r3
 440 001a 9AB2     	 uxth r2,r3
 441 001c 074B     	 ldr r3,.L26+12
 442 001e 1A80     	 strh r2,[r3]
 100:../transform.c **** 	//	speed_value_fast = 1;
 101:../transform.c **** 	timer_value_old_fast = timer_value_fast;
 443              	 .loc 1 101 0
 444 0020 044B     	 ldr r3,.L26+4
 445 0022 1A88     	 ldrh r2,[r3]
 446 0024 044B     	 ldr r3,.L26+8
 447 0026 1A80     	 strh r2,[r3]
 102:../transform.c **** }
 448              	 .loc 1 102 0
 449 0028 BD46     	 mov sp,r7
 450              	.LCFI16:
 451              	 .cfi_def_cfa_register 13
 452              	 
 453 002a 5DF8047B 	 ldr r7,[sp],#4
 454              	.LCFI17:
 455              	 .cfi_restore 7
 456              	 .cfi_def_cfa_offset 0
 457 002e 7047     	 bx lr
 458              	.L27:
 459              	 .align 2
 460              	.L26:
 461 0030 00C10040 	 .word 1073791232
 462 0034 00000000 	 .word timer_value_fast
 463 0038 00000000 	 .word timer_value_old_fast
 464 003c 00000000 	 .word speed_value_fast
 465              	 .cfi_endproc
 466              	.LFE199:
 468              	 .section .text.compute_fast_mechanical_position,"ax",%progbits
 469              	 .align 2
 470              	 .global compute_fast_mechanical_position
 471              	 .thumb
 472              	 .thumb_func
 474              	compute_fast_mechanical_position:
 475              	.LFB200:
 103:../transform.c **** /*
 104:../transform.c ****  * Compute the mechanical position based on the speed value
 105:../transform.c ****  */
 106:../transform.c **** void compute_fast_mechanical_position(void)
 107:../transform.c **** {
 476              	 .loc 1 107 0
 477              	 .cfi_startproc
 478              	 
 479              	 
 480              	 
 481 0000 80B4     	 push {r7}
 482              	.LCFI18:
 483              	 .cfi_def_cfa_offset 4
 484              	 .cfi_offset 7,-4
 485 0002 00AF     	 add r7,sp,#0
 486              	.LCFI19:
 487              	 .cfi_def_cfa_register 7
 108:../transform.c **** 	mechanical_position_fast += speed_value_fast;
 488              	 .loc 1 108 0
 489 0004 054B     	 ldr r3,.L29
 490 0006 1B88     	 ldrh r3,[r3]
 491 0008 1AB2     	 sxth r2,r3
 492 000a 054B     	 ldr r3,.L29+4
 493 000c 1B68     	 ldr r3,[r3]
 494 000e 1344     	 add r3,r3,r2
 495 0010 034A     	 ldr r2,.L29+4
 496 0012 1360     	 str r3,[r2]
 109:../transform.c **** }
 497              	 .loc 1 109 0
 498 0014 BD46     	 mov sp,r7
 499              	.LCFI20:
 500              	 .cfi_def_cfa_register 13
 501              	 
 502 0016 5DF8047B 	 ldr r7,[sp],#4
 503              	.LCFI21:
 504              	 .cfi_restore 7
 505              	 .cfi_def_cfa_offset 0
 506 001a 7047     	 bx lr
 507              	.L30:
 508              	 .align 2
 509              	.L29:
 510 001c 00000000 	 .word speed_value_fast
 511 0020 00000000 	 .word mechanical_position_fast
 512              	 .cfi_endproc
 513              	.LFE200:
 515              	 .section .text.compute_fast_electrical_position,"ax",%progbits
 516              	 .align 2
 517              	 .global compute_fast_electrical_position
 518              	 .thumb
 519              	 .thumb_func
 521              	compute_fast_electrical_position:
 522              	.LFB201:
 110:../transform.c **** 
 111:../transform.c **** /*
 112:../transform.c ****  * Compute the module of the electrical position based on the mechanical position
 113:../transform.c ****  */
 114:../transform.c **** void compute_fast_electrical_position(void)
 115:../transform.c **** {
 523              	 .loc 1 115 0
 524              	 .cfi_startproc
 525              	 
 526              	 
 527              	 
 528 0000 80B4     	 push {r7}
 529              	.LCFI22:
 530              	 .cfi_def_cfa_offset 4
 531              	 .cfi_offset 7,-4
 532 0002 00AF     	 add r7,sp,#0
 533              	.LCFI23:
 534              	 .cfi_def_cfa_register 7
 116:../transform.c **** 	electrical_position_modulo_fast = mechanical_position_fast % electrical_resolution;
 535              	 .loc 1 116 0
 536 0004 074B     	 ldr r3,.L32
 537 0006 1B68     	 ldr r3,[r3]
 538 0008 074A     	 ldr r2,.L32+4
 539 000a 1288     	 ldrh r2,[r2]
 540 000c 12B2     	 sxth r2,r2
 541 000e 93FBF2F1 	 sdiv r1,r3,r2
 542 0012 02FB01F2 	 mul r2,r2,r1
 543 0016 9B1A     	 subs r3,r3,r2
 544 0018 044A     	 ldr r2,.L32+8
 545 001a 1360     	 str r3,[r2]
 117:../transform.c **** }
 546              	 .loc 1 117 0
 547 001c BD46     	 mov sp,r7
 548              	.LCFI24:
 549              	 .cfi_def_cfa_register 13
 550              	 
 551 001e 5DF8047B 	 ldr r7,[sp],#4
 552              	.LCFI25:
 553              	 .cfi_restore 7
 554              	 .cfi_def_cfa_offset 0
 555 0022 7047     	 bx lr
 556              	.L33:
 557              	 .align 2
 558              	.L32:
 559 0024 00000000 	 .word mechanical_position_fast
 560 0028 00000000 	 .word electrical_resolution
 561 002c 00000000 	 .word electrical_position_modulo_fast
 562              	 .cfi_endproc
 563              	.LFE201:
 565              	 .section .text.compute_fast_field,"ax",%progbits
 566              	 .align 2
 567              	 .global compute_fast_field
 568              	 .thumb
 569              	 .thumb_func
 571              	compute_fast_field:
 572              	.LFB202:
 118:../transform.c **** 
 119:../transform.c **** /*
 120:../transform.c ****  * Compute the electrical angle based on the electrical position
 121:../transform.c ****  * Compute the sin&cos of theta
 122:../transform.c ****  */
 123:../transform.c **** void compute_fast_field(void)
 124:../transform.c **** {
 573              	 .loc 1 124 0
 574              	 .cfi_startproc
 575              	 
 576              	 
 577 0000 80B5     	 push {r7,lr}
 578              	.LCFI26:
 579              	 .cfi_def_cfa_offset 8
 580              	 .cfi_offset 7,-8
 581              	 .cfi_offset 14,-4
 582 0002 00AF     	 add r7,sp,#0
 583              	.LCFI27:
 584              	 .cfi_def_cfa_register 7
 125:../transform.c **** 	theta_fast = electrical_position_modulo_fast * (2 * Pi) / electrical_resolution;
 585              	 .loc 1 125 0
 586 0004 134B     	 ldr r3,.L36
 587 0006 1B68     	 ldr r3,[r3]
 588 0008 07EE903A 	 fmsr s15,r3
 589 000c F8EEE77A 	 fsitos s15,s15
 590 0010 9FED117A 	 flds s14,.L36+4
 591 0014 27EE877A 	 fmuls s14,s15,s14
 592 0018 104B     	 ldr r3,.L36+8
 593 001a 1B88     	 ldrh r3,[r3]
 594 001c 1BB2     	 sxth r3,r3
 595 001e 07EE903A 	 fmsr s15,r3
 596 0022 F8EEE77A 	 fsitos s15,s15
 597 0026 C7EE277A 	 fdivs s15,s14,s15
 598 002a 0D4B     	 ldr r3,.L36+12
 599 002c C3ED007A 	 fsts s15,[r3]
 126:../transform.c **** 	if (loop_control & TUNE_REF_LOOP_MSK)
 600              	 .loc 1 126 0
 601 0030 0C4B     	 ldr r3,.L36+16
 602 0032 1B78     	 ldrb r3,[r3]
 603 0034 DBB2     	 uxtb r3,r3
 604 0036 5BB2     	 sxtb r3,r3
 605 0038 002B     	 cmp r3,#0
 606 003a 03DA     	 bge .L35
 127:../transform.c **** 	{
 128:../transform.c **** 		theta_fast = 0;
 607              	 .loc 1 128 0
 608 003c 084B     	 ldr r3,.L36+12
 609 003e 4FF00002 	 mov r2,#0
 610 0042 1A60     	 str r2,[r3]
 611              	.L35:
 129:../transform.c **** 	}
 130:../transform.c **** 	sincosf(theta_fast, &sin_theta_fast, &cos_theta_fast);
 612              	 .loc 1 130 0
 613 0044 064B     	 ldr r3,.L36+12
 614 0046 1B68     	 ldr r3,[r3]
 615 0048 1846     	 mov r0,r3
 616 004a 0749     	 ldr r1,.L36+20
 617 004c 074A     	 ldr r2,.L36+24
 618 004e FFF7FEFF 	 bl sincosf
 131:../transform.c **** }
 619              	 .loc 1 131 0
 620 0052 80BD     	 pop {r7,pc}
 621              	.L37:
 622              	 .align 2
 623              	.L36:
 624 0054 00000000 	 .word electrical_position_modulo_fast
 625 0058 D00FC940 	 .word 1086918608
 626 005c 00000000 	 .word electrical_resolution
 627 0060 00000000 	 .word theta_fast
 628 0064 00000000 	 .word loop_control
 629 0068 00000000 	 .word sin_theta_fast
 630 006c 00000000 	 .word cos_theta_fast
 631              	 .cfi_endproc
 632              	.LFE202:
 634              	 .text
 635              	.Letext0:
 636              	 .file 2 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 637              	 .file 3 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 638              	 .file 4 "C:/GitHub/Stepper_drive/Libraries/CMSIS/Infineon/XMC4800_series/Include/XMC4800.h"
 639              	 .file 5 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\math.h"
 640              	 .file 6 "C:/GitHub/Stepper_drive/Libraries/CMSIS/Include/core_cm4.h"
 641              	 .file 7 "../main.h"
 642              	 .file 8 "../driver_adc.h"
 643              	 .file 9 "../pi_regulator.h"
 644              	 .file 10 "../state_machine.h"
DEFINED SYMBOLS
                            *ABS*:00000000 transform.c
                            *COM*:00000004 CCU8_CC8_CR1_CR1_Value
    {standard input}:25     .bss.mechanical_position_fast:00000000 mechanical_position_fast
    {standard input}:22     .bss.mechanical_position_fast:00000000 $d
    {standard input}:32     .bss.electrical_position_modulo_fast:00000000 electrical_position_modulo_fast
    {standard input}:29     .bss.electrical_position_modulo_fast:00000000 $d
    {standard input}:39     .bss.theta_fast:00000000 theta_fast
    {standard input}:36     .bss.theta_fast:00000000 $d
    {standard input}:46     .bss.sin_theta_fast:00000000 sin_theta_fast
    {standard input}:43     .bss.sin_theta_fast:00000000 $d
    {standard input}:53     .bss.cos_theta_fast:00000000 cos_theta_fast
    {standard input}:50     .bss.cos_theta_fast:00000000 $d
    {standard input}:60     .bss.timer_value_fast:00000000 timer_value_fast
    {standard input}:57     .bss.timer_value_fast:00000000 $d
    {standard input}:67     .bss.timer_value_old_fast:00000000 timer_value_old_fast
    {standard input}:64     .bss.timer_value_old_fast:00000000 $d
    {standard input}:74     .bss.speed_value_fast:00000000 speed_value_fast
    {standard input}:71     .bss.speed_value_fast:00000000 $d
    {standard input}:81     .bss.encoder_resolution:00000000 encoder_resolution
    {standard input}:78     .bss.encoder_resolution:00000000 $d
    {standard input}:87     .bss.pp:00000000 pp
    {standard input}:88     .bss.pp:00000000 $d
    {standard input}:94     .bss.electrical_resolution:00000000 electrical_resolution
    {standard input}:91     .bss.electrical_resolution:00000000 $d
                            *COM*:00000004 u_a_ref
                            *COM*:00000004 u_b_ref
                            *COM*:00000004 u_c_ref
                            *COM*:00000004 i_d
                            *COM*:00000004 i_q
                            *COM*:00000004 i_alpha
                            *COM*:00000004 i_beta
                            *COM*:00000004 u_alpha
                            *COM*:00000004 u_beta
    {standard input}:106    .text.motor_data_init:00000000 $t
    {standard input}:111    .text.motor_data_init:00000000 motor_data_init
    {standard input}:178    .text.motor_data_init:00000050 $d
    {standard input}:185    .text.abc_dq:00000000 $t
    {standard input}:190    .text.abc_dq:00000000 abc_dq
    {standard input}:261    .text.abc_dq:00000088 $d
    {standard input}:273    .text.dq_abc:00000000 $t
    {standard input}:278    .text.dq_abc:00000000 dq_abc
    {standard input}:393    .text.dq_abc:000000e0 $d
    {standard input}:408    .text.compute_fast_speed:00000000 $t
    {standard input}:413    .text.compute_fast_speed:00000000 compute_fast_speed
    {standard input}:461    .text.compute_fast_speed:00000030 $d
    {standard input}:469    .text.compute_fast_mechanical_position:00000000 $t
    {standard input}:474    .text.compute_fast_mechanical_position:00000000 compute_fast_mechanical_position
    {standard input}:510    .text.compute_fast_mechanical_position:0000001c $d
    {standard input}:516    .text.compute_fast_electrical_position:00000000 $t
    {standard input}:521    .text.compute_fast_electrical_position:00000000 compute_fast_electrical_position
    {standard input}:559    .text.compute_fast_electrical_position:00000024 $d
    {standard input}:566    .text.compute_fast_field:00000000 $t
    {standard input}:571    .text.compute_fast_field:00000000 compute_fast_field
    {standard input}:624    .text.compute_fast_field:00000054 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ia
ic
u_d_ref
u_q_ref
sincosf
loop_control
